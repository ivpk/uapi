# Introduction

This document is an API specification template for all Lithuanian government
institutions.

Institutions implementing API should reuse most of the specification as is and
only add customizable parts expressed as path parameters or schema fields
specified as a pattern.

This specification should be used together with
[DSA](https://ivpk.github.io/dsa) specification.

UAPI provides a template for data exchange protocol and DSA provides schemas.

Final API specification should be generated by combining UAPI and DSA together
and this (in future) can be done in Data Portal (data.gov.lt).


## Specifications

- [UAPI](https://ivpk.github.io/uapi) - this document, describes data exchange
  protocol and format.

- [DSA](https://ivpk.github.io/dsa) - Data Structure Mapping table format
  specification, describes a table format, for mapping data models between
  Physical, Logical and Conceptual data models.

  Logical data model from DSA tables are used as API schemas. UDTS only
  describes protocol, DSA tables provides data schemas for UDTS API.

  DSA and UDTS are used together.

- DCAT-AP-LT - a semantic data model specification, based on BregDCAT-AP.


## Contact Details

This document is maintained by Lithuanian [Information Society Development
Community](https://ivpk.lrv.lt/) (IVPK).

If you found an error in the document, you can report it by registering a
[GitHub issue](https://github.com/ivpk/uapi/issues/new).


## Legal basis

This specification is provided in accordance to

- [Lietuvos respublikos valstybės informacinių išteklių valdymo įstatymas
  (XI-1807)](https://www.e-tar.lt/portal/lt/legalAct/TAR.85C510BA700A/asr),
- [Dėl duomenų teikimo formatų ir standartų rekomendacijų patvirtinimo
  (T-36)](https://e-seimas.lrs.lt/portal/legalAct/lt/TAD/TAIS.445504/asr).


# Architecture

![](static/architecture.png)

Diagram above provides a high level overview listing main components involved
in data exchange.

This document mainly describes data exchange protocol which is implemented by
**Data Agent**.


## Components

Data exchange and interoperability architecture consists of following main
components:

- **Data** source and **Data Service** - these components represents all data
  sources, including variuos databases, web services, CSV, XLSX or other data
  tables maintained by all the government institutions.

  Data might be read directly from a primary data source or through a data
  service. 

- **Data agent** - is a software component similar to **Data Service** but
  published data in a standardized UDTS protocol and format.

  IVPK provides an [Universal Data Agent
  solution](https://github.com/atviriduomenys/spinta/), which uses DSA table to
  convert between data source and UDTS protocol and data format.

  Organizations are free to implement their own Data Agent solution according
  to UDTS specification.

- **Data Catalog** - is used cataloging datasets from all public institutions.
  Data Catalog is built on top of
  [DCAT-AP](https://op.europa.eu/en/web/eu-vocabularies/dcat-ap) data model and
  provides user interface for managing DSA tables.

  Data Catalog is also used to manage smart data contracts.

  Data Catalog receives DSA tables from Data Agent, provides modified versions
  of DSA tables back to Data Agent, exports API specifications to API Gateway
  in OpenAPI format and exports available data scopes and information about
  smart contracts into Auth service.

  Data Catalog does not have access to data, it is used only to manage metadata
  about data.

- **API Gateway** - is used as a reverse proxy and passes Data user requests to
  one of many Data agent. Data Agents can't be accessed directly, they are
  available only through API Gateway.

  API Gateway provides load balancing, rate limiting, request validation
  against OpenAPI schemas, access token validation with Auth service and
  request logging and metrics.

- **Auth service** - provides client and user authentication and authorization
  services, supporting both OAuth [Client
  Credentials](https://oauth.net/2/grant-types/client-credentials/) and
  [Authorization Code](https://oauth.net/2/grant-types/authorization-code/)
  flows.

Diagram is divided in two main data and metadata flows.


## Metadata flow

First **metadata flow** is needed to produce a final API specification in
OpenAPI format. This involves following steps:

1. **Data Agent** extracts data structure from Data source or Data Service in
   [DSA](https://ivpk.github.io/dsa) table format and passes it to **Data
   Catalog**.

   At the same time, **Data Agent** receives updated DSA version from **Data
   Catalog**.

   This process is automated and DSA metadata exchange is done periodically
   (for example once every day).

2. Data steward from each organization manually edits DSA tables using **Data
   Catalog** or other means, to map physical data model with logical data model
   which will be used to publish data. Logical data model is aligned with a
   [conceptual data
   model](https://semiceu.github.io/style-guide/1.0.0/gc-conceptual-model-conventions.html).

3. DSA tables marked as ready for publishing are converted into JSON Schemas
   and merged with UDTS OpenAPI specification template to produce final OpenAPI
   specification, which is published in **API Gateway**.

   At the same time list of available authorization scopes are generated from
   code names specified in DSA table and published to **Authentication and
   authorization service**.


## Data flow

Next **data flow** represents, how actual data moves through all the
components:

1. **Data Agent** reads data directly from **Data source** or through a **Data
   Service**. Data Agent supports multiple data exchange protocols and formats.

   Data Agent uses DSA table to transform data between physical and logical
   data models and between source protocol and format into standardized UDTS
   data exchange protocol using JSON format.

2. **Data Agent** performs data authorization, using authorization scopes.
   Authorization scopes are validated with **Auth Service**. Using
   authorization scopes and DSA, Data Agent applies data filters in order to
   return only those data objects, which are available for a specific data
   user.

3. **API Gateway** works as a reverse proxy and load balancer, accepts requests
   from data users, validates these requests against OpenAPI schemas received
   from **Data Catalog**, validates authorization tokens with **Auth service**,
   provides request logging, rate limiting and other services.

   **API Gateway** after initial validation, passed requests to **Data Agent**,
   which reads data from primary sources and provides protocol and format
   conversions.

4. **Data user** authenticates using **Auth service** and receives access token,
   which authorization scopes. Using access token, Data user makes request to
   API Gateway by providing access token and receives data or error response if
   something goes wrong.


# Concepts

## URI schema

All API URI's are constructed using one of the following patters:

- Get list of objects:

  `/datasets/`
  <span class="green">form</span> `/`
  <span class="green">org</span> `/`
  <span class="green">catalog</span> `/`
  <span class="green">dataset</span> `/`
  <span class="green">version</span> `/`
  <span class="green">model<span>

- Get single object:

  `/datasets/`
  <span class="green">form</span> `/`
  <span class="green">org</span> `/`
  <span class="green">catalog</span> `/`
  <span class="green">dataset</span> `/`
  <span class="green">version</span> `/`
  <span class="green">model</span> `/`
  <span class="green">id</span>

- Get single object value:

  `/datasets/`
  <span class="green">form</span> `/`
  <span class="green">org</span> `/`
  <span class="green">catalog</span> `/`
  <span class="green">dataset</span> `/`
  <span class="green">version</span> `/`
  <span class="green">model</span> `/`
  <span class="green">property</span>

  `/datasets/`
  <span class="green">form</span> `/`
  <span class="green">org</span> `/`
  <span class="green">catalog</span> `/`
  <span class="green">dataset</span> `/`
  <span class="green">version</span> `/`
  <span class="green">model</span> `/`
  <span class="green">id</span> `/`
  <span class="green">property</span>

- Perform a custom action on an object or a list of objects:

  `/datasets/`
  <span class="green">form</span> `/`
  <span class="green">org</span> `/`
  <span class="green">catalog</span> `/`
  <span class="green">dataset</span> `/`
  <span class="green">version</span> `/`
  <span class="green">model</span> `/:`
  <span class="green">controller</span>

  `/datasets/`
  <span class="green">form</span> `/`
  <span class="green">org</span> `/`
  <span class="green">catalog</span> `/`
  <span class="green">dataset</span> `/`
  <span class="green">version</span> `/`
  <span class="green">model</span> `/`
  <span class="green">id</span> `/:`
  <span class="green">controller</span>

- Legacy API, or APIs that do not support standart UAPI exchange protocol:

  `/services/`
  <span class="green">form</span> `/`
  <span class="green">org</span> `/`
  <span class="green">catalog</span> `/`
  <span class="green">dataset</span> `/`
  <span class="green">version</span> `/`
  <span class="green">service</span>


Meaning of dynamic URI parts explained bollow:

- <span class="green">form</span> - legal form of an organization can be `gov`
  for government or `com` for private sector.
- <span class="green">org</span> - a short code name of an organization.
- <span class="green">catalog</span> - a short code name of an information
  system or a project
  providing data.
- <span class="green">dataset</span> - a short code name of a specific dataset
  from a catalog.
- <span class="green">version</span> - data schema version of a dataset.
- <span class="green">model</span> - a set of objects provided under the same
  data model.
- <span class="green">id</span> - unique object identifier in UUID format.
- <span class="green">property</span> - a subresource used for some property
  data types liek files or arrays, in order to retrieve large content blobs.
- <span class="green">controller</span> - an action performed with objects or a
  single object.
- <span class="green">service</span> - a service endpoint, that does not follow
  UAPI requirements, used of existing legacy API services.

URI example:

```text
/datasets/gov/rc/ar/ws/Location/e96cc0cc-08be-460d-a887-98f80612a402
```

## Global identifier

Global identifiers are assigned to real or fictional world entities. For
example, there can be a building in real world, global identifier would be
assigned to the building as a real object.

That means, there can't be two different global identifiers, pointing to the
same building.

Different datasets and different models might have multiple local identifiers
assigned by a database management system or a registry, all local identifiers
must be mapped to a single global identifier.

When exchanging data, objects are only identified using global identifiers.

There can be multiple separate datasets and multiple models providing data form
same building, but the global identifier must be the same for all datasets.

Global identifiers must be assigned to all objects using a reserved property
name `_id`.

For example we can have multiple datasets containing data abould the same
building, since building is the same, single global identifier must be used:

```text
/datasets/gov/rc/ar/ws/Location/e96cc0cc-08be-460d-a887-98f80612a402
/datasets/gov/rc/ntr/report/Pastatas/e96cc0cc-08be-460d-a887-98f80612a402
```

## Model

Real world entities are identified using global identifiers. Each real world
entity might have different data shape, form or schema.

Single real world entity might be represented using multiple different data
models using different set of properties, but different models must share the
same global identifier for the same entity.

A model is just a data schema for an entity.

Model name is provided by the reserved `_type` property:

```json
{
    "_type": "datasets/gov/rc/ar/ws/Location",
    "_id": "e96cc0cc-08be-460d-a887-98f80612a402"
}
```


## Object

A single data entity provided by a specific data model is called object.
Objects are associate with data models, when we reference we must provide
global identifier and model, to know the entity and data model used to describe
the entity.

Object must have at least `_type` and `_id` properties:


```json
{
    "_type": "datasets/gov/rc/ar/ws/Location",
    "_id": "e96cc0cc-08be-460d-a887-98f80612a402"
}
```


## Reference

Reference is an object property pointing to another object. Reference must
provide global identifier of a referenced object.

For example:

```json
{
    "_type": "datasets/gov/rc/ar/ws/Country",
    "_id": "e96cc0cc-08be-460d-a887-98f80612a402",
    "name": "Lithuania",
    "capital": {
        "_id": "60b9bafd-dac7-4579-a435-31c80b593384"
    }
}
```

Here, `capital` is a property of `datasets/gov/rc/ar/ws/Country` model and is a
reference to another object.



## Resource

Resource is a document, containing one or multiple objects.

For example:

```json
{
    "_type": "datasets/gov/rc/ar/ws/Country",
    "_id": "e96cc0cc-08be-460d-a887-98f80612a402",
    "name": "Lithuania",
    "capital": {
        "_id": "60b9bafd-dac7-4579-a435-31c80b593384",
        "name": "Vilnius"
    }
}
```

Resource above, has two objects.


## Subresource

Some types of properties might have subresources in order to separately return
large blobs of data.

For example if `datasets/gov/rc/ar/ws/Country` model has a `flag` property of
`file` type, then file content must be returned separately:

```text
GET /datasets/gov/rc/ar/ws/Country/e96cc0cc-08be-460d-a887-98f80612a402
```

```json
{
    "_type": "datasets/gov/rc/ar/ws/Country",
    "_id": "e96cc0cc-08be-460d-a887-98f80612a402",
    "name": "Lithuania",
    "flag": {
        "_content_type": "image/png",
        "_name": "flag.png",
        "_size": "1584684"
    }
}
```

When we do a resource call, we don't get file content, in order to get file
content we must do a separate API call to a subresource:

```text
GET /datasets/gov/rc/ar/ws/Country/e96cc0cc-08be-460d-a887-98f80612a402/flag
```

And this will return raw image data as `image/png` content type.


## Controller

Controller is an action performed with objects. Controllers in URI always
starts with a `:` symbol:

```text
GET datasets/gov/rc/ar/ws/Country/:changes
```

This lists all changes made to `Country` objects. This is a controller, that
works with multiple objects.

But also, there can be a controller on a single object:

```text
GET datasets/gov/rc/ar/ws/Country/e96cc0cc-08be-460d-a887-98f80612a402/:changes
```

There is a list of build-in reserved implicit controllers, where you don't need
to specify controller name:

- `GET /…/{model}` (`:getall`) - get list of objects.
- `GET /…/{model}/{id}` (`:getone`) - get a single object.
- `GET /…/{model}?{query}` (`:search`) - get list of objects with a filter.
- `POST /…/{model}` (`:create`) - create new object.
- `PUT /…/{model}/{id}` (`:update`) - rewrite whole existing object.
- `PATCH /…/{model}/{id}` (`:path`) - update some properties of existing object.
- `DELETE /…/{model}/{id}` (`:delete`) - delete an existing object.

Also there are some built-in reserved explicit controllers:

- `GET /…/{model}/:changes` - get list of changes to all model objects.
- `GET /…/{model}/{id}/:changes` - get list of changes to a single object.
- `DELETE /…/{model}/{id}/:wipe` - completely remove object without storing changes in changelog.


Data agents might implement custom controllers.




# REST API

This Data API is an integral part of the Data Portal. The purpose of the Data
Portal is to provide metadata at the highest level of maturity, in various
formats, and corresponding data via a convenient machine-readable interface
(API), adhering to the highest data publishing standards.

All datasets provided by this API are combined into a large data map, where
data can be interconnected, presented in bulk or in desired slices. Operations
are provided for downloading data incrementally.

The API is generated dynamically from the model code names located in the
[**DSA**](https://atviriduomenys.readthedocs.io/dsa/index.html) model column.
Model names can have namespaces, and namespaces are separated by the `/`
symbol, for example:

    /datasets/gov/ivpk/dp/dcat/Dataset

This address is made of the `datasets/gov/ivpk/dp/dcat` namespace and the
`Dataset` model name.

The `datasets` namespace indicates that the data is raw, i.e., as provided by a
certain institution. Over time, all institutional data will be transformed into
a uniform national dictionary, and for example `datasets/gov/dc/geo/Continent`
may be merged into a common `Continent` model in the root namespace. This
namespace is likely to be `onthology`, thus defining a specific ruleset for the
rest of the URI structure based on a national or EU semantic model. It would be
supported by a national metadata catalog, that would be maintained by all
organisations in scope and would provide a way to understand and find datasets
or their internal structures.

However, to ensure a stable and constant API, the initial raw data API
endpoints and URIs will be preserved.

Specifically, all models in the `datasets` namespace have a clearly defined
structure. For example, while examining the `datasets/gov/dc/geo/Continent`
example, the meanings of the separate path components are as follows:

- `datasets/` - namespace for raw primary institutional data.
- `gov/` - namespace for government institution data.
- `dc/` - acronym for a specific government institution.
- `geo/` - abbreviation for the institution's open data set.
- `Continent` - data model (or table).

Once the system is fully operational, this API, and other APIs based on this
specification will be provided by an unified endpoint api.gov.lt.
