# Introduction

This document is an API specification template for all Lithuanian government
institutions.

Institutions implementing API should reuse most of the specification as is and
only add customizable parts expressed as path parameters or schema fields
specified as a pattern.

This specification should be used together with
[DSA](https://ivpk.github.io/dsa) specification.

UAPI provides a template for data exchange protocol and DSA provides schemas.

Final API specification should be generated by combining UAPI and DSA together
and this (in future) can be done in Data Portal (data.gov.lt).


## Specifications

- [UAPI](https://ivpk.github.io/uapi) - this document, describes data exchange
  protocol and format.

- [DSA](https://ivpk.github.io/dsa) - Data Structure Mapping table format
  specification, describes a table format, for mapping data models between
  Physical, Logical and Conceptual data models.

  Logical data model from DSA tables are used as API schemas. UDTS only
  describes protocol, DSA tables provides data schemas for UDTS API.

  DSA and UDTS are used together.

- DCAT-AP-LT - a semantic data model specification, based on BregDCAT-AP.


## Contact Details

This document is maintained by Lithuanian [Information Society Development
Community](https://ivpk.lrv.lt/) (IVPK).

If you found an error in the document, you can report it by registering a
[GitHub issue](https://github.com/ivpk/uapi/issues/new).


## Legal basis

This specification is provided in accordance to

- [Lietuvos respublikos valstybės informacinių išteklių valdymo įstatymas
  (XI-1807)](https://www.e-tar.lt/portal/lt/legalAct/TAR.85C510BA700A/asr),
- [Dėl duomenų teikimo formatų ir standartų rekomendacijų patvirtinimo
  (T-36)](https://e-seimas.lrs.lt/portal/legalAct/lt/TAD/TAIS.445504/asr).


# Architecture

![](static/architecture.png)

Diagram above provides a high level overview listing main components involved
in data exchange.

This document mainly describes data exchange protocol which is implemented by
**Data Agent**.


## Components

Data exchange and interoperability architecture consists of following main
components:

- **Data** source and **Data Service** - these components represents all data
  sources, including variuos databases, web services, CSV, XLSX or other data
  tables maintained by all the government institutions.

  Data might be read directly from a primary data source or through a data
  service. 

- **Data agent** - is a software component similar to **Data Service** but
  published data in a standardized UDTS protocol and format.

  IVPK provides an [Universal Data Agent
  solution](https://github.com/atviriduomenys/spinta/), which uses DSA table to
  convert between data source and UDTS protocol and data format.

  Organizations are free to implement their own Data Agent solution according
  to UDTS specification.

- **Data Catalog** - is used cataloging datasets from all public institutions.
  Data Catalog is built on top of
  [DCAT-AP](https://op.europa.eu/en/web/eu-vocabularies/dcat-ap) data model and
  provides user interface for managing DSA tables.

  Data Catalog is also used to manage smart data contracts.

  Data Catalog receives DSA tables from Data Agent, provides modified versions
  of DSA tables back to Data Agent, exports API specifications to API Gateway
  in OpenAPI format and exports available data scopes and information about
  smart contracts into Auth service.

  Data Catalog does not have access to data, it is used only to manage metadata
  about data.

- **API Gateway** - is used as a reverse proxy and passes Data user requests to
  one of many Data agent. Data Agents can't be accessed directly, they are
  available only through API Gateway.

  API Gateway provides load balancing, rate limiting, request validation
  against OpenAPI schemas, access token validation with Auth service and
  request logging and metrics.

- **Auth service** - provides client and user authentication and authorization
  services, supporting both OAuth [Client
  Credentials](https://oauth.net/2/grant-types/client-credentials/) and
  [Authorization Code](https://oauth.net/2/grant-types/authorization-code/)
  flows.

Diagram is divided in two main data and metadata flows.


## Metadata flow

First **metadata flow** is needed to produce a final API specification in
OpenAPI format. This involves following steps:

1. **Data Agent** extracts data structure from Data source or Data Service in
   [DSA](https://ivpk.github.io/dsa) table format and passes it to **Data
   Catalog**.

   At the same time, **Data Agent** receives updated DSA version from **Data
   Catalog**.

   This process is automated and DSA metadata exchange is done periodically
   (for example once every day).

2. Data steward from each organization manually edits DSA tables using **Data
   Catalog** or other means, to map physical data model with logical data model
   which will be used to publish data. Logical data model is aligned with a
   [conceptual data
   model](https://semiceu.github.io/style-guide/1.0.0/gc-conceptual-model-conventions.html).

3. DSA tables marked as ready for publishing are converted into JSON Schemas
   and merged with UDTS OpenAPI specification template to produce final OpenAPI
   specification, which is published in **API Gateway**.

   At the same time list of available authorization scopes are generated from
   code names specified in DSA table and published to **Authentication and
   authorization service**.


## Data flow

Next **data flow** represents, how actual data moves through all the
components:

1. **Data Agent** reads data directly from **Data source** or through a **Data
   Service**. Data Agent supports multiple data exchange protocols and formats.

   Data Agent uses DSA table to transform data between physical and logical
   data models and between source protocol and format into standardized UDTS
   data exchange protocol using JSON format.

2. **Data Agent** performs data authorization, using authorization scopes.
   Authorization scopes are validated with **Auth Service**. Using
   authorization scopes and DSA, Data Agent applies data filters in order to
   return only those data objects, which are available for a specific data
   user.

3. **API Gateway** works as a reverse proxy and load balancer, accepts requests
   from data users, validates these requests against OpenAPI schemas received
   from **Data Catalog**, validates authorization tokens with **Auth service**,
   provides request logging, rate limiting and other services.

   **API Gateway** after initial validation, passed requests to **Data Agent**,
   which reads data from primary sources and provides protocol and format
   conversions.

4. **Data user** authenticates using **Auth service** and receives access token,
   which authorization scopes. Using access token, Data user makes request to
   API Gateway by providing access token and receives data or error response if
   something goes wrong.


# Concepts

## URI schema

All API URI's are constructed using one of the following patters:

- Get list of objects:

  `/datasets/`
  <span class="green">form</span> `/`
  <span class="green">org</span> `/`
  <span class="green">catalog</span> `/`
  <span class="green">dataset</span> `/`
  <span class="green">version</span> `/`
  <span class="green">model<span>

- Get single object:

  `/datasets/`
  <span class="green">form</span> `/`
  <span class="green">org</span> `/`
  <span class="green">catalog</span> `/`
  <span class="green">dataset</span> `/`
  <span class="green">version</span> `/`
  <span class="green">model</span> `/`
  <span class="green">id</span>

- Get single object value:

  `/datasets/`
  <span class="green">form</span> `/`
  <span class="green">org</span> `/`
  <span class="green">catalog</span> `/`
  <span class="green">dataset</span> `/`
  <span class="green">version</span> `/`
  <span class="green">model</span> `/`
  <span class="green">property</span>

  `/datasets/`
  <span class="green">form</span> `/`
  <span class="green">org</span> `/`
  <span class="green">catalog</span> `/`
  <span class="green">dataset</span> `/`
  <span class="green">version</span> `/`
  <span class="green">model</span> `/`
  <span class="green">id</span> `/`
  <span class="green">property</span>

- Perform a custom action on an object or a list of objects:

  `/datasets/`
  <span class="green">form</span> `/`
  <span class="green">org</span> `/`
  <span class="green">catalog</span> `/`
  <span class="green">dataset</span> `/`
  <span class="green">version</span> `/`
  <span class="green">model</span> `/:`
  <span class="green">action</span>

  `/datasets/`
  <span class="green">form</span> `/`
  <span class="green">org</span> `/`
  <span class="green">catalog</span> `/`
  <span class="green">dataset</span> `/`
  <span class="green">version</span> `/`
  <span class="green">model</span> `/`
  <span class="green">id</span> `/:`
  <span class="green">action</span>

- Legacy API, or APIs that do not support standart UAPI exchange protocol:

  `/services/`
  <span class="green">form</span> `/`
  <span class="green">org</span> `/`
  <span class="green">catalog</span> `/`
  <span class="green">dataset</span> `/`
  <span class="green">version</span> `/`
  <span class="green">service</span>


Meaning of dynamic URI parts explained bollow:

- <span class="green">form</span> - legal form of an organization can be `gov`
  for government or `com` for private sector.
- <span class="green">org</span> - a short code name of an organization.
- <span class="green">catalog</span> - a short code name of an information
  system or a project
  providing data.
- <span class="green">dataset</span> - a short code name of a specific dataset
  from a catalog.
- <span class="green">version</span> - data schema version of a dataset.
- <span class="green">model</span> - a set of objects provided under the same
  data model.
- <span class="green">id</span> - unique object identifier in UUID format.
- <span class="green">property</span> - a subresource used for some property
  data types liek files or arrays, in order to retrieve large content blobs.
- <span class="green">action</span> - an action performed with objects or a
  single object.
- <span class="green">service</span> - a service endpoint, that does not follow
  UAPI requirements, used of existing legacy API services.

URI example:

```text
/datasets/gov/rc/ar/ws/Location/e96cc0cc-08be-460d-a887-98f80612a402
```

## Global identifier

Global identifiers are assigned to real or fictional world entities. For
example, there can be a building in real world, global identifier would be
assigned to the building as a real object.

That means, there can't be two different global identifiers, pointing to the
same building.

Different datasets and different models might have multiple local identifiers
assigned by a database management system or a registry, all local identifiers
must be mapped to a single global identifier.

When exchanging data, objects are only identified using global identifiers.

There can be multiple separate datasets and multiple models providing data form
same building, but the global identifier must be the same for all datasets.

Global identifiers must be assigned to all objects using a reserved property
name `_id`.

For example we can have multiple datasets containing data abould the same
building, since building is the same, single global identifier must be used:

```text
/datasets/gov/rc/ar/ws/Location/e96cc0cc-08be-460d-a887-98f80612a402
/datasets/gov/rc/ntr/report/Pastatas/e96cc0cc-08be-460d-a887-98f80612a402
```

## Model

Real world entities are identified using global identifiers. Each real world
entity might have different data shape, form or schema.

Single real world entity might be represented using multiple different data
models using different set of properties, but different models must share the
same global identifier for the same entity.

A model is just a data schema for an entity.

Model name is provided by the reserved `_type` property:

```json
{
    "_type": "datasets/gov/rc/ar/ws/Location",
    "_id": "e96cc0cc-08be-460d-a887-98f80612a402"
}
```


## Object

A single data entity provided by a specific data model is called object.
Objects are associate with data models, when we reference we must provide
global identifier and model, to know the entity and data model used to describe
the entity.

Object must have at least `_type` and `_id` properties:


```json
{
    "_type": "datasets/gov/rc/ar/ws/Location",
    "_id": "e96cc0cc-08be-460d-a887-98f80612a402"
}
```


## Reference

Reference is an object property pointing to another object. Reference must
provide global identifier of a referenced object.

For example:

```json
{
    "_type": "datasets/gov/rc/ar/ws/Country",
    "_id": "e96cc0cc-08be-460d-a887-98f80612a402",
    "name": "Lithuania",
    "capital": {
        "_id": "60b9bafd-dac7-4579-a435-31c80b593384"
    }
}
```

Here, `capital` is a property of `datasets/gov/rc/ar/ws/Country` model and is a
reference to another object.



## Resource

Resource is a document, containing one or multiple objects.

For example:

```json
{
    "_type": "datasets/gov/rc/ar/ws/Country",
    "_id": "e96cc0cc-08be-460d-a887-98f80612a402",
    "name": "Lithuania",
    "capital": {
        "_id": "60b9bafd-dac7-4579-a435-31c80b593384",
        "name": "Vilnius"
    }
}
```

Resource above, has two objects.


## Subresource

Some types of properties might have subresources in order to separately return
large blobs of data.

For example if `datasets/gov/rc/ar/ws/Country` model has a `flag` property of
`file` type, then file content must be returned separately:

```text
GET /datasets/gov/rc/ar/ws/Country/e96cc0cc-08be-460d-a887-98f80612a402
```

```json
{
    "_type": "datasets/gov/rc/ar/ws/Country",
    "_id": "e96cc0cc-08be-460d-a887-98f80612a402",
    "name": "Lithuania",
    "flag": {
        "_content_type": "image/png",
        "_name": "flag.png",
        "_size": "1584684"
    }
}
```

When we do a resource call, we don't get file content, in order to get file
content we must do a separate API call to a subresource:

```text
GET /datasets/gov/rc/ar/ws/Country/e96cc0cc-08be-460d-a887-98f80612a402/flag
```

And this will return raw image data as `image/png` content type.


## Action

An action performed with multiple objects or a single object. Action name in a
URI is denoted with a `:` symbol, for example:

```text
GET datasets/gov/rc/ar/ws/Country/:changes
```

In the example above action name is `changes` and it lists all changes made to
`Country` objects. This is an action, that works on multiple objects.

But also, there can be an action on a single object:

```text
GET datasets/gov/rc/ar/ws/Country/e96cc0cc-08be-460d-a887-98f80612a402/:changes
```

There is a list of build-in reserved implicit actions, where you don't need to
specify action name:

- `GET /…/{model}` (`:getall`) - get list of objects.
- `GET /…/{model}/{id}` (`:getone`) - get a single object.
- `GET /…/{model}?{query}` (`:search`) - get list of objects with a filter.
- `POST /…/{model}` (`:create`) - create new object.
- `PUT /…/{model}/{id}` (`:update`) - rewrite whole existing object.
- `PATCH /…/{model}/{id}` (`:path`) - update some properties of existing object.
- `DELETE /…/{model}/{id}` (`:delete`) - delete an existing object.

Also there are some built-in reserved explicit actions:

- `GET /…/{model}/:changes` - get list of changes to all model objects.
- `GET /…/{model}/{id}/:changes` - get list of changes to a single object.
- `DELETE /…/{model}/{id}/:wipe` - completely remove object without storing
  changes in changelog.

Data agents might implement custom actions.



# Authorization

Authorization must be implemented using OAuth 2.0 protocol.

In order to understand authorization process, first we need to understand all
the parties participating in data exchange process:

- **User** - a person (a human being), that has access to data, a person can
  represent himself or act as an organization representative. In OAuth terms,
  this is a Resource Owner.

- **Client** - a software (mobile, web or other application), that can act on
  behalf of a user or itself.

- **Auth** - authentication and authorization server responsible for
  authenticating users and clients, issues access tokens. In OAuth terms this
  is a Authorization Server.

- **Catalog** - a data catalog, a place where all information about agents,
  resource, clients and smart contracts are registered.

- **Resource** - a data service, a database or a data file, place where data
  are stored.

- **Agent** - a software responsible for data exchange, accepts data queries,
  reads data from a Resource and returns data via API using UDTS exchange
  protocol.

- **Gateway** - a reverse proxy, responsible for routing client requests to
  multiple Agents and performs basic request data and access token validation.


Following authorization flows (grant types) are supported:

- Authorization code - for granting access to a specific User on behalf of a Client.
- Client credentials - for granting access directly to a Client, who acts on its own.


## Registration

![](static/auth-smart-contracts.png)

In order to get access to data, before any data exchange happens, following
steps must be completed:

1. An Agent must be installed and configured in order to be able to access
   Resource data. Agents should be installed on the same infrastructure as
   Resource.

2. Agent inspects Resource data structure (DSA) and published collected information
   about data structure to Catalog.

3. Data steward organized data structures (DSA) into datasets, and specifies
   what data can be use for exchange outside if Resource and published this
   information for Client developers.

4. Client developers discovers published datasets, registers client and
   requests access to data they need. After registration, clients receive
   client id and client secret assigned by the Authorization server.

5. Resource maintainers reviews data access requests and by approving access
   creates a smart contract. Information about smart contract is published to
   Authorization serve. Authorization server knows what clients and what data
   (scopes) can access.

6. Agent and Gateway registers themselves with the Authorization servers and
   receives public keys from Authorization server needed for access token
   validation.

When all these steps are completed all parties are ready for data exchange.


## Client authorization

![](static/auth-client-credentials.png)

For client authorization client credentials flow (or grant type) is used, when
client is granted access to data as a system service acting on its own without
representing any specific user.

In order to make requests, following steps are needed:

1. Client, uses client id and secret received at client registration time, to
   get access token from Authorization server:

   ```http
   POST /token HTTP/1.1
   Host: auth.gov.lt
   Authorization: Basic YjRjNTMyNDktMTQxZC00OTI2LWE5YzQtNjBjNGJiNjVlZWJmOnNlY3JldAo=

   grant_type=client_credentials&
   resource=https://api.gov.lt/&
   scope=uapi:/datasets/gov/rc/ar/ws/Country/:getall
   ```

   Authorization server returns JWT access token in a following JSON response:

   ```json
   {
     "token_type": "Bearer",
     "expires_in": 3600,
     "access_token": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJqdGkiOiI3ZWFkODU5MS01ZDUxLTQyNjQtYjFiMi1iNzk0M2UxNDIxNzUiLCJpc3MiOiJodHRwczovL2F1dGguZ292Lmx0LyIsImF1ZCI6Imh0dHBzOi8vYXBpLmdvdi5sdC8iLCJleHAiOjE2Mzk1Mjg5MTIsImlhdCI6MTYxODM1NDA5MCwic3ViIjoiNTMzMmM5Y2UtYmM5OC00YzRlLWExMjItYjgxZTVmOTQ5OGZjIiwiY2xpZW50X2lkIjoiYjRjNTMyNDktMTQxZC00OTI2LWE5YzQtNjBjNGJiNjVlZWJmIiwic2NvcGUiOiJ1YXBpOi9kYXRhc2V0cy9nb3YvcmMvYXIvd3MvQ291bnRyeS86Z2V0YWxsIn0.CcvXCq7_iSpWQJR5N_cGficA6EmDtQZoGxdaToA7OG0",
     "scope": "uapi:/datasets/gov/rc/ar/ws/Country/:getall"
   }
   ```

   Payload of JWT token (`access_token` value) looks like this:

   ```json
   {
     "jti": "7ead8591-5d51-4264-b1b2-b7943e142175",
     "iss": "https://auth.gov.lt/",
     "aud": "https://api.gov.lt/",
     "exp": 1639528912,
     "iat": 1618354090,
     "sub": "b4c53249-141d-4926-a9c4-60c4bb65eebf",
     "client_id": "b4c53249-141d-4926-a9c4-60c4bb65eebf",
     "scope": "uapi:/datasets/gov/rc/ar/ws/Country/:getall"
   }
   ```

   When client acts on behalf of itself, `sub` and `client_id` must be the same.


2. Client then uses received access token, to get data like this:


   ```http
   GET /datasets/gov/rc/ar/ws/Country HTTP/1.1
   Host: api.gov.lt
   Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJqdGkiOiI3ZWFkODU5MS01ZDUxLTQyNjQtYjFiMi1iNzk0M2UxNDIxNzUiLCJpc3MiOiJodHRwczovL2F1dGguZ292Lmx0LyIsImF1ZCI6Imh0dHBzOi8vYXBpLmdvdi5sdC8iLCJleHAiOjE2Mzk1Mjg5MTIsImlhdCI6MTYxODM1NDA5MCwic3ViIjoiNTMzMmM5Y2UtYmM5OC00YzRlLWExMjItYjgxZTVmOTQ5OGZjIiwiY2xpZW50X2lkIjoiYjRjNTMyNDktMTQxZC00OTI2LWE5YzQtNjBjNGJiNjVlZWJmIiwic2NvcGUiOiJ1YXBpOi9kYXRhc2V0cy9nb3YvcmMvYXIvd3MvQ291bnRyeS86Z2V0YWxsIn0.CcvXCq7_iSpWQJR5N_cGficA6EmDtQZoGxdaToA7OG0
   ```

   Request must be made to API Gateway, which validate access token using
   public key received from Authorization server and validates request data
   using OpenAPI schema received from Catalog.

3. Gateway passes Client request to Agent, which again repeats token and
   request data validation.

   In addition to access token validation performed on Gateway, Agent
   interprets given scope values and ensures, that Client has access to the
   requested Resource.

4. Finally Agent transforms an UAPI request into a protocol, that is understood
   by a Resource, retrieves data and transforms result back to UAPI.



## User authorization

![](static/auth-authorization-code.png)

For user authorization authorization code flow (or grant type) is used.

1. A User (a human being) uses a Client application in order to access a
   Resource.

2. Client redirects User to Authorization server, where User can authenticate
   and allow Client to act on behalf of User.

   When redirecting, following URL is constructed to the Authorization server:

   ```uri
   https://auth.gov.lt/auth?
     response_type=code&
     client_id=b4c53249-141d-4926-a9c4-60c4bb65eebf&
     redirect_uri=https://app.example.com/auth&
     scope=uapi:/datasets/gov/rc/ar/ws/Country/:getall&
     state=xcoiv98y2kd22vusuye3kch
   ```

3. Authorization server asks User to identify himself by providing user name
   and password or other means of authentication.

   After authentication, User is asked if he agrees to authorize Client
   application with scopes request by the Client application.

   If agreed, then Authorization server redirects User back to the Client
   application with following URL:

   ```uri
   https://app.example.com/auth?
     response_type=code&
     state=xcoiv98y2kd22vusuye3kch&
     code=g0ZGZmNjVmOWIjNTk2NTk4ZTYyZGI3
   ```

4. After successful User authentication, Client receives authorization code
   (`code`) from Authorization server.

   Client uses authorization code to get access token by making following
   request to Authorization server:

   ```http
   POST /token HTTP/1.1
   Host: auth.gov.lt
   Authorization: Basic YjRjNTMyNDktMTQxZC00OTI2LWE5YzQtNjBjNGJiNjVlZWJmOnNlY3JldAo=

   grant_type=authorization_code&
   code=g0ZGZmNjVmOWIjNTk2NTk4ZTYyZGI3&
   resource=https://api.gov.lt/&
   scope=uapi:/datasets/gov/rc/ar/ws/Country/:getall
   ```
   Authorization server returns JWT access token in a following JSON response:

   ```json
   {
     "token_type": "Bearer",
     "expires_in": 3600,
     "access_token": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJqdGkiOiI3ZWFkODU5MS01ZDUxLTQyNjQtYjFiMi1iNzk0M2UxNDIxNzUiLCJpc3MiOiJodHRwczovL2F1dGguZ292Lmx0LyIsImF1ZCI6Imh0dHBzOi8vYXBpLmdvdi5sdC8iLCJleHAiOjE2Mzk1Mjg5MTIsImlhdCI6MTYxODM1NDA5MCwic3ViIjoiNDA2M2YxYzAtN2Q4NC00MzBjLTliZDEtMWE0YmM5ZjdhZWFlIiwiY2xpZW50X2lkIjoiYjRjNTMyNDktMTQxZC00OTI2LWE5YzQtNjBjNGJiNjVlZWJmIiwic2NvcGUiOiJ1YXBpOi9kYXRhc2V0cy9nb3YvcmMvYXIvd3MvQ291bnRyeS86Z2V0YWxsIn0.I3BQ41W_-BHtrxBoPF_wmE92gfxI9T7DPCqcSZe7-v8",
     "scope": "uapi:/datasets/gov/rc/ar/ws/Country/:getall"
   }
   ```

   Payload of JWT token (`access_token` value) looks like this:

   ```json
   {
     "jti": "7ead8591-5d51-4264-b1b2-b7943e142175",
     "iss": "https://auth.gov.lt/",
     "aud": "https://api.gov.lt/",
     "exp": 1639528912,
     "iat": 1618354090,
     "sub": "4063f1c0-7d84-430c-9bd1-1a4bc9f7aeae",
     "client_id": "b4c53249-141d-4926-a9c4-60c4bb65eebf",
     "scope": "uapi:/datasets/gov/rc/ar/ws/Country/:getall"
   }
   ```

   When client acts on behalf of a User, `sub` is a global identifier of a
   representative, which is also must be used by the Resource in data, to
   reference a representative. 

   `sub` references not the User itself, bet a representative. Representative
   can represent an organization or a User itself. This distinction is needed,
   because Resource server might give different permissions of an employee of
   an organization and for a person not associated with an organization.

   Row level access scope might use representative identifier (`sub`) in order
   to filter data that is only available for the representative.

5. All other steps are the same as described for the [Client
   authorization](#section/Authorization/Client-authorization).



# Query

Actions might use URI query to filter, limit, sort or otherwise influence
result returned by an action.

URI consists of following components (there are more components, but for
simplicity reasons in this example are only listed main ones):

<span class="green">scheme</span> `://`
<span class="green">host</span> `/`
<span class="green">path</span> `?`
<span class="green">query</span>

Query has name and value pairs called parameters:

<span class="green">name</span> `=`
<span class="green">value</span>

There can be multiple query parameters separated by `&` symbol.

<span class="green">param</span> `&`
<span class="green">param</span>

Parameter names can have one of two forms:

- Reserved names - all names starting with `_` are reserved and has a function
  or a predefined meaning.
- Property names - all names not starting with `_` are interpreted as model
  property names and can be used to filter data by a property value.

Parameter names can have attributes:

<span class="green">name</span> `.`
<span class="green">attribute</span> `=`
<span class="green">value</span> `&`

There can be none, one or more than one attribute.

For query examples following data model will be used.

```mermaid
classDiagram
  direction LR
  class Country {
      code: string
      name: string
      population: integer
  }
  class City {
      name: string
  }

  Country <-- City : country
```

## Filtering

Simple filtering can be done like this:

```uri
Country?code=lt
```

This will filter countries by `code`.

It is also possible to filter using different comparison operators, for example:

```uri
Country?population._gt=1000
```

List of all available operators:

- `_gt` - greater than
- `_ge` - greater than or equal
- `_lt` - less than
- `_le` - less than than or equal
- `_sw` - starts with
- `_ew` - ends with
- `_co` - contains


## Selecting

By default, all model properties are returned, but it is possible to select
only specific properties using `_select`:

```uri
Country?_select=code,name
```

This will return data containing only `code` and `name` properties.


## Sorting

By default objects are sorted by `_id`, but you can change order with `_sort`:

```uri
Country?_sort=name
```

By default sorting is done in ascending (a-z) order, but this can also be
changed:

```uri
Country?_sort=-name
```

You can sort by multiple properties in different directions:


```uri
Country?_sort=-name,+code,population
```

## Limiting

By default all objects are returned, but you can limit number of objects
returned with `_limit`:

```uri
Country?_limit=10
```

This will limit result set to 10 objects.


## Counting

You can get total number of available objects with `_count`:

```uri
Country?_count=
```

## Pagination

If number of objects is too large to get in a single request, you can use
`_page` in combination with `_limit` and `_sort` to get all data in multiple
pages.

By default pagination is enabled if you specify `_limit`:

```uri
Country?_limit=10
```

This will enable pagination and query above is equivalent to:

```uri
Country?_sort=_id&_limit=10
```

Objects are ordered by `_id` by default, so we don't need to specify `_sort`,
unless we want to change pagination key:

```uri
Country?_sort=code&_limit=10
```

When `_limit` is given, response document will include `_next` attribute
pointing to the next page:

```json
{
    "_data": [...],
    "_next": "ImE3N2IyNWU1LWUzMDMtNGE4ZS04Y2YzLTllZmMyNWVlMjI0NiIK"
}
```

You can get next page with `_page` query parameter:

```uri
Country?_sort=code&_limit=10&_page=ImE3N2IyNWU1LWUzMDMtNGE4ZS04Y2YzLTllZmMyNWVlMjI0NiIK
```

`_page` value is a base64 encoded (with `+/=` characters replaced with `-_.` to
make it user safe) JSON string. In this case, decoded `_page` value is:

```json
"a77b25e5-e303-4a8e-8cf3-9efc25ee2246"
```

If result is sorted by more than one property, then `_page` JSON value will be
an array, for example if we have:

```uri
Country?_sort=_id,code&_limit=10
```

Then decoded `_page` value will be:

```json
["a77b25e5-e303-4a8e-8cf3-9efc25ee2246","lt"]
```

Pagination might be enabled by default, by the Agent, this will be indicated in
the result data:

```json
{
    "_data": [...],
    "_next": "ImE3N2IyNWU1LWUzMDMtNGE4ZS04Y2YzLTllZmMyNWVlMjI0NiIK",
    "_limit": 1000
}
```

Presence of `_limit` and `_next` in the result, indicates, that limit is
enforced by the Agent.


# Data types

## ref

<SchemaDefinition schemaRef="#/components/schemas/ref" />

## file

<SchemaDefinition schemaRef="#/components/schemas/file" />
